<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mirrored City Army Builder (Pure HTML)</title>
  <style>
    :root{
      --bg:#0f0f12;
      --panel:#171720;
      --panel2:#1d1d29;
      --text:#f2f2f7;
      --muted:#a9a9b8;
      --line:#2a2a3a;
      --bad:#ff5a5f;
      --good:#4ade80;
      --warn:#fbbf24;
      --btn:#2a2a3a;
      --btnHover:#36364e;
      --input:#101018;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
    }
    header{
      position:sticky; top:0; z-index:10;
      background: linear-gradient(180deg, #151522, #101018);
      border-bottom:1px solid var(--line);
      padding:14px 16px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
    }
    header h1{
      margin:0;
      font-size:16px;
      letter-spacing:0.2px;
      font-weight:700;
    }
    .sub{color:var(--muted); font-size:12px; margin-top:2px;}
    .hdr-left{display:flex; flex-direction:column}
    .hdr-actions{display:flex; flex-wrap:wrap; gap:8px; align-items:center}

    button{
      border:1px solid var(--line);
      background:var(--btn);
      color:var(--text);
      border-radius:10px;
      padding:8px 10px;
      font-weight:600;
      cursor:pointer;
      font-size:13px;
    }
    button:hover{background:var(--btnHover)}
    button:disabled{opacity:.55; cursor:not-allowed}

    main{
      padding:16px;
      display:grid;
      grid-template-columns: 1.8fr 1fr;
      gap:16px;
      max-width:1200px;
      margin:0 auto;
    }
    @media (max-width: 980px){ main{grid-template-columns:1fr} }

    .panel{
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:16px;
      padding:14px;
      box-shadow: 0 8px 24px rgba(0,0,0,.25);
    }
    .row{display:grid; gap:10px}
    .row.two{grid-template-columns:1fr 1fr}
    @media (max-width: 700px){ .row.two{grid-template-columns:1fr} }

    label{
      display:block;
      color:var(--muted);
      font-size:12px;
      margin: 8px 0 6px;
    }
    input[type="text"], input[type="number"], select, textarea{
      width:100%;
      background:var(--input);
      color:var(--text);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px 10px;
      outline:none;
      font-size:14px;
    }
    textarea{min-height:80px; resize:vertical}

    .muted{color:var(--muted); font-size:12px}
    .tiny{font-size:11px; color:var(--muted)}
    .hr{height:1px; background:var(--line); margin:12px 0}

    .cards{display:flex; flex-direction:column; gap:10px; margin-top:8px}
    .card{
      background:var(--panel2);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
    }
    .card-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      border:1px solid var(--line);
      padding:4px 8px;
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
      background:rgba(255,255,255,0.02);
      white-space:nowrap;
    }
    .pill.good{border-color: rgba(74,222,128,.45); color:var(--good)}
    .pill.bad{border-color: rgba(255,90,95,.45); color:var(--bad)}
    .pill.warn{border-color: rgba(251,191,36,.45); color:var(--warn)}
    .card-title{
      display:flex; flex-wrap:wrap;
      gap:8px;
      align-items:center;
      font-weight:800;
    }

    .summary-grid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
    }
    .stat{
      background:rgba(255,255,255,0.03);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px;
    }
    .stat .k{color:var(--muted); font-size:12px}
    .stat .v{font-weight:800; font-size:16px; margin-top:4px}

    .badBorder{border-color: rgba(255,90,95,.45) !important}
    .goodBorder{border-color: rgba(74,222,128,.45) !important}

    .errors{
      margin-top:12px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .err{
      border:1px solid rgba(255,90,95,.35);
      background: rgba(255,90,95,.08);
      border-radius:14px;
      padding:10px;
      font-size:13px;
    }
    .warnBox{
      border:1px solid rgba(251,191,36,.35);
      background: rgba(251,191,36,.08);
      border-radius:14px;
      padding:10px;
      font-size:13px;
    }
    .okBox{
      border:1px solid rgba(74,222,128,.35);
      background: rgba(74,222,128,.08);
      border-radius:14px;
      padding:10px;
      font-size:13px;
    }

    .btnRow{display:flex; flex-wrap:wrap; gap:8px; margin-top:10px}

    .slotGrid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 900px){
      .slotGrid{grid-template-columns:1fr}
    }

    .slotBox{
      border:1px solid var(--line);
      background: rgba(255,255,255,0.02);
      border-radius:14px;
      padding:10px;
    }
    .slotBox .slotHdr{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      margin-bottom:6px;
    }
    .slotBox .slotHdr strong{font-size:13px}
    .slotBox .slotHdr span{font-size:11px; color:var(--muted)}
    .slotAddRow{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px;
      align-items:end;
    }
    @media (max-width: 700px){
      .slotAddRow{grid-template-columns:1fr}
    }

    .equipList{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:8px;
    }
    .equipChip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      border:1px solid var(--line);
      background: rgba(255,255,255,0.02);
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      color:var(--text);
    }
    .equipChip .x{
      cursor:pointer;
      color:var(--muted);
      font-weight:900;
      user-select:none;
    }
    .equipChip .x:hover{color:var(--text)}
    .tagMini{color:var(--muted); font-size:11px}

    @media print{
      header, .noPrint{display:none !important}
      body{background:#fff; color:#000}
      .panel{box-shadow:none; border:1px solid #ddd}
      .card{border:1px solid #ddd}
      .pill{border:1px solid #ddd; color:#444}
      .muted{color:#444}
      .equipChip{border:1px solid #ddd}
      .slotBox{border:1px solid #ddd}
    }
  </style>
</head>

<body>
  <header class="noPrint">
    <div class="hdr-left">
      <h1>Mirrored City Army Builder</h1>
      <div class="sub">Pure HTML • Upload via cPanel • Auto-saves locally</div>
    </div>
    <div class="hdr-actions">
      <button id="btnExport">Export</button>
      <button id="btnImport">Import</button>
      <button id="btnPrint">Print</button>
      <button id="btnReset">Reset</button>
    </div>
  </header>

  <main>
    <!-- LEFT -->
    <section class="panel">
      <div class="row two">
        <div>
          <label>Roster Name</label>
          <input id="rosterName" type="text" placeholder="e.g., Echo Thirteen Patrol" />
        </div>
        <div>
          <label>Creation Mode</label>
          <select id="creationMode">
            <option value="starting">Starting Warband (creation rules enforced)</option>
          </select>
          <div class="tiny">
            Starting mode hides <strong>RARE</strong> items (except <strong>Unique equipment</strong>).
          </div>
        </div>
      </div>

      <div class="row two">
        <div>
          <label>Warband</label>
          <select id="warbandSelect"></select>
          <div id="warbandDesc" class="tiny"></div>
        </div>

        <div>
          <label>Archetype</label>
          <select id="archetypeSelect"></select>
          <div id="archetypeDesc" class="tiny"></div>
        </div>
      </div>

      <div class="row two">
        <div>
          <label>Leader</label>
          <select id="leaderSelect"></select>
          <div class="tiny">
            Leader counts as a <strong>Stat Card</strong> and counts toward the <strong>Hero</strong> cap.
          </div>
        </div>
        <div>
          <label class="muted">Notes</label>
          <div class="tiny">
            Archetype controls which Leaders/Heroes/Henchmen you can select.
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="btnRow noPrint">
        <button id="btnAddHero">+ Add Hero Card</button>
        <button id="btnAddHench">+ Add Henchman Card</button>
      </div>

      <div class="tiny">
        Equipment slots per Stat Card: <strong>3 Weapons</strong>, <strong>1 Helmet</strong>, <strong>1 Armor</strong>, <strong>1 Shield</strong>, <strong>3 Everything Else</strong>.
      </div>

      <div class="cards" id="cards"></div>
    </section>

    <!-- RIGHT -->
    <aside class="panel">
      <h2 style="margin:0 0 10px 0; font-size:16px;">Summary</h2>

      <div class="summary-grid">
        <div class="stat" id="statLumens">
          <div class="k">Lumens</div>
          <div class="v" id="lumensText">0 / 500</div>
          <div class="tiny" id="lumensSub"></div>
        </div>
        <div class="stat" id="statCards">
          <div class="k">Stat Cards (incl. Leader)</div>
          <div class="v" id="cardsText">0 / 5</div>
          <div class="tiny" id="cardsSub"></div>
        </div>
        <div class="stat" id="statHeroes">
          <div class="k">Heroes (incl. Leader)</div>
          <div class="v" id="heroesText">0 / 3</div>
          <div class="tiny">Max 3 at creation (Leader included).</div>
        </div>
        <div class="stat" id="statReqs">
          <div class="k">Requirements</div>
          <div style="margin-top:8px; display:flex; flex-wrap:wrap; gap:6px;">
            <span class="pill" id="reqLeader">Leader</span>
            <span class="pill" id="reqHench">Henchman Card</span>
            <span class="pill" id="reqOneMore">+1 Card</span>
            <span class="pill" id="reqMinCards">≥3 Cards</span>
            <span class="pill" id="reqNoSells">No Sellswords</span>
          </div>
        </div>
      </div>

      <div class="errors" id="messages"></div>

      <div class="hr"></div>

      <label class="noPrint">Roster JSON (read-only preview)</label>
      <textarea id="jsonPreview" readonly></textarea>
      <div class="tiny">Export/Import uses this format. Local save is in your browser only.</div>
    </aside>
  </main>

<script>
/* =========================================================
   RULES
   ========================================================= */

const RULES = {
  startingLumens: 500,
  startingStatCardsMax: 5,          // NOW includes Leader
  startingStatCardsMinFilled: 3,     // includes Leader if selected
  startingMaxHeroesIncludingLeader: 3,
  sellswordsAllowedAtCreation: false,

  equipSlots: {
    WEAPON: 3,
    HELMET: 1,
    ARMOR: 1,
    SHIELD: 1,
    OTHER: 3
  }
};

/* =========================================================
   UNITS (Order of the Last Sun)
   ========================================================= */

const UNITS = [
  // LEADERS
  { id: "ols_vindicator", name: "Vindicator", type: "LEADER", cost: 70, tags: [], limit: "1" },
  { id: "ols_justicar", name: "Justicar", type: "LEADER", cost: 65, tags: [], limit: "1" },
  { id: "ols_dawnfather", name: "Dawnfather / Dawnmother", type: "LEADER", cost: 60, tags: [], limit: "0-1" },

  // HEROES
  { id: "ols_purifier", name: "Purifier", type: "HERO", cost: 40, tags: [], limit: "0-3" },
  { id: "ols_suntouched_vessel", name: "Suntouched Vessel", type: "HERO", cost: 50, tags: [], limit: "" },
  { id: "ols_chaplain", name: "Chaplain", type: "HERO", cost: 55, tags: [], limit: "0-1" },
  { id: "ols_sunward_initiate", name: "Sunward Initiate", type: "HERO", cost: 25, tags: [], limit: "0-2" },
  { id: "ols_dawnguard", name: "Dawnguard", type: "HERO", cost: 45, tags: [], limit: "0-2" },

  // HENCHMEN
  { id: "ols_warhound", name: "Warhound", type: "HENCHMAN", cost: 15, tags: [], limit: "0-6" },
  { id: "ols_man_at_arms", name: "Man-at-Arms", type: "HENCHMAN", cost: 25, tags: [], limit: "" },
  { id: "ols_dawner", name: "Dawner", type: "HENCHMAN", cost: 20, tags: ["HORDE"], limit: "" },
  { id: "ols_vigilant", name: "Vigilant", type: "HENCHMAN", cost: 25, tags: [], limit: "0-6" },

  // Example sellsword placeholder
  { id: "sell_blade_for_hire", name: "Blade for Hire", type: "SELLSWORD", cost: 60, tags: [], limit: "" }
];

/* =========================================================
   CENTRAL EQUIPMENT CATALOG (hidden from UI)
   - You said you will need to access these later: we keep them in data,
     but we REMOVE the on-page Equipment Catalog display.
   - RARE items (tag: "RARE") do NOT appear at start, unless they are Unique equipment.
   - Special materials exist as entries, but:
     - excluded from "Universal Equipment"
     - you said you don't know how to handle them yet, so we don't surface them in any slot right now.
   ========================================================= */

const EQUIPMENT_CATALOG = {
  /* ---- Weapons (pg 23-25 tables) ---- */
  // Melee
  eq_axe: { id:"eq_axe", name:"Axe", tags:["WEAPON","MELEE"], cost:8 },
  eq_dagger: { id:"eq_dagger", name:"Dagger", tags:["WEAPON","MELEE"], cost:0, note:"1st Free / 2" },
  eq_flail: { id:"eq_flail", name:"Flail", tags:["WEAPON","MELEE"], cost:18 },
  eq_great_weapon: { id:"eq_great_weapon", name:"Great Weapon", tags:["WEAPON","MELEE","TWO_HANDED"], cost:25 },
  eq_halberd: { id:"eq_halberd", name:"Halberd", tags:["WEAPON","MELEE","TWO_HANDED"], cost:12 },
  eq_hammer: { id:"eq_hammer", name:"Hammer", tags:["WEAPON","MELEE"], cost:8 },
  eq_mace: { id:"eq_mace", name:"Mace", tags:["WEAPON","MELEE"], cost:6 },
  eq_mace_chain: { id:"eq_mace_chain", name:"Mace and Chain", tags:["WEAPON","MELEE"], cost:20 },
  eq_sword: { id:"eq_sword", name:"Sword", tags:["WEAPON","MELEE"], cost:15 },
  eq_club: { id:"eq_club", name:"Club", tags:["WEAPON","MELEE"], cost:3 },
  eq_staff: { id:"eq_staff", name:"Staff", tags:["WEAPON","MELEE","TWO_HANDED"], cost:8 },
  eq_rapier: { id:"eq_rapier", name:"Rapier", tags:["WEAPON","MELEE"], cost:10 },
  eq_whip: { id:"eq_whip", name:"Whip", tags:["WEAPON","MELEE"], cost:5 },
  eq_spear: { id:"eq_spear", name:"Spear", tags:["WEAPON","MELEE","TWO_HANDED"], cost:10 },

  // Ranged
  eq_crossbow: { id:"eq_crossbow", name:"Crossbow", tags:["WEAPON","RANGED"], cost:25 },
  eq_hand_crossbow: { id:"eq_hand_crossbow", name:"Hand Crossbow", tags:["WEAPON","RANGED"], cost:15 },
  eq_short_bow: { id:"eq_short_bow", name:"Short Bow", tags:["WEAPON","RANGED"], cost:10 },
  eq_long_bow: { id:"eq_long_bow", name:"Long Bow", tags:["WEAPON","RANGED"], cost:15 },
  eq_sling: { id:"eq_sling", name:"Sling", tags:["WEAPON","RANGED"], cost:9 },
  eq_javelin: { id:"eq_javelin", name:"Javelin", tags:["WEAPON","RANGED","THROWN"], cost:15 },
  eq_throwing_axe: { id:"eq_throwing_axe", name:"Throwing Axe", tags:["WEAPON","RANGED","THROWN"], cost:10 },
  eq_throwing_knives: { id:"eq_throwing_knives", name:"Throwing Knives", tags:["WEAPON","RANGED","THROWN"], cost:8 },

  // Blastpowder
  eq_pistol: { id:"eq_pistol", name:"Pistol", tags:["WEAPON","BLASTPOWDER","RANGED"], cost:20 },
  eq_dueling_pistol: { id:"eq_dueling_pistol", name:"Dueling Pistol", tags:["WEAPON","BLASTPOWDER","RANGED"], cost:35 },
  eq_volley_pistol: { id:"eq_volley_pistol", name:"Volley Pistol", tags:["WEAPON","BLASTPOWDER","RANGED"], cost:30 },
  eq_blunderbuss: { id:"eq_blunderbuss", name:"Blunderbuss", tags:["WEAPON","BLASTPOWDER","RANGED"], cost:30 },
  eq_musket: { id:"eq_musket", name:"Musket", tags:["WEAPON","BLASTPOWDER","RANGED"], cost:40 },
  eq_long_rifle: { id:"eq_long_rifle", name:"Long Rifle", tags:["WEAPON","BLASTPOWDER","RANGED"], cost:100 },

  /* ---- Helmets / Armor / Shields (pg 26 tables) ---- */
  eq_helmet: { id:"eq_helmet", name:"Helmet", tags:["HELMET"], cost:5 },
  eq_great_helmet: { id:"eq_great_helmet", name:"Great Helmet", tags:["HELMET"], cost:8 },

  eq_light_armor: { id:"eq_light_armor", name:"Light Armor", tags:["ARMOR"], cost:10 },
  eq_medium_armor: { id:"eq_medium_armor", name:"Medium Armor", tags:["ARMOR"], cost:25 },
  eq_heavy_armor: { id:"eq_heavy_armor", name:"Heavy Armor", tags:["ARMOR"], cost:45 },

  eq_shield: { id:"eq_shield", name:"Shield", tags:["SHIELD"], cost:10 },
  eq_tower_shield: { id:"eq_tower_shield", name:"Tower Shield", tags:["SHIELD"], cost:18 },
  eq_buckler: { id:"eq_buckler", name:"Buckler", tags:["SHIELD"], cost:5 },

  /* ---- Universal Equipment (pg 27-31, excluding special materials) ---- */
  // (some of these are RARE; those will be hidden at start)
  eq_divine_focus: { id:"eq_divine_focus", name:"Divine Focus", tags:["UNIVERSAL"], cost:20, restrictions:"PRIEST only." },
  eq_prayer_scrolls: { id:"eq_prayer_scrolls", name:"Prayer Scrolls", tags:["UNIVERSAL","CONSUMABLE","RARE"], cost:"50+3D6", restrictions:"HERO only." },
  eq_grappling_iron: { id:"eq_grappling_iron", name:"Grappling Iron", tags:["UNIVERSAL"], cost:5 },
  eq_hooded_lantern: { id:"eq_hooded_lantern", name:"Hooded Lantern", tags:["UNIVERSAL"], cost:10 },
  eq_signal_horn: { id:"eq_signal_horn", name:"Signal Horn", tags:["UNIVERSAL"], cost:25, restrictions:"LEADER only." },
  eq_elven_cloak: { id:"eq_elven_cloak", name:"Elven Cloak", tags:["UNIVERSAL","RARE"], cost:"50+3D6", restrictions:"LEADER and HERO only. Not DWARF." },
  eq_healers_kit: { id:"eq_healers_kit", name:"Healer’s Kit", tags:["UNIVERSAL"], cost:20 },
  eq_arcane_focus: { id:"eq_arcane_focus", name:"Arcane Focus", tags:["UNIVERSAL"], cost:20, restrictions:"WIZARD only." },
  eq_holy_symbol: { id:"eq_holy_symbol", name:"Holy Symbol", tags:["UNIVERSAL","RARE"], cost:"15+3D6", restrictions:"LEADER and HERO only." },
  eq_spellbook: { id:"eq_spellbook", name:"Spellbook", tags:["UNIVERSAL","CONSUMABLE","RARE"], cost:"50+3D6", restrictions:"HERO only." },

  eq_blastpowder_bomb: { id:"eq_blastpowder_bomb", name:"Blastpowder Bomb", tags:["UNIVERSAL","CONSUMABLE","RARE"], cost:15 },
  eq_caltrops: { id:"eq_caltrops", name:"Caltrops", tags:["UNIVERSAL","CONSUMABLE"], cost:5 },
  eq_net: { id:"eq_net", name:"Net", tags:["UNIVERSAL","RARE"], cost:8 },
  eq_atlatl: { id:"eq_atlatl", name:"Atlatl", tags:["UNIVERSAL"], cost:"4/8" },
  eq_bola: { id:"eq_bola", name:"Bola", tags:["UNIVERSAL","RARE"], cost:5 },
  eq_torch: { id:"eq_torch", name:"Torch", tags:["UNIVERSAL"], cost:2 },

  eq_blastpowder_arrow: { id:"eq_blastpowder_arrow", name:"Blastpowder Arrow", tags:["UNIVERSAL","CONSUMABLE","RARE"], cost:"10+D6" },
  eq_holy_water: { id:"eq_holy_water", name:"Holy Water", tags:["UNIVERSAL","CONSUMABLE","RARE"], cost:"10+3D6" },
  eq_dwarven_blastpowder: { id:"eq_dwarven_blastpowder", name:"Dwarven Blastpowder", tags:["UNIVERSAL","CONSUMABLE","RARE"], cost:"25+2D6" },

  eq_black_lotus: { id:"eq_black_lotus", name:"Black Lotus", tags:["UNIVERSAL","CONSUMABLE","ADDICTING","RARE"], cost:"15+D6" },
  eq_healing_draught: { id:"eq_healing_draught", name:"Healing Draught", tags:["UNIVERSAL","CONSUMABLE","RARE"], cost:20 },
  eq_antitoxin: { id:"eq_antitoxin", name:"Antitoxin", tags:["UNIVERSAL","CONSUMABLE","RARE"], cost:"20+D6" },
  eq_pipeweed: { id:"eq_pipeweed", name:"Pipeweed", tags:["UNIVERSAL","CONSUMABLE"], cost:10 },
  eq_grog: { id:"eq_grog", name:"Grog", tags:["UNIVERSAL","CONSUMABLE"], cost:"15/30" },
  eq_street_dust: { id:"eq_street_dust", name:"Street Dust", tags:["UNIVERSAL","CONSUMABLE"], cost:15 },
  eq_witchs_milk: { id:"eq_witchs_milk", name:"Witch’s Milk", tags:["UNIVERSAL","CONSUMABLE"], cost:30 },
  eq_dreamtoad_venom: { id:"eq_dreamtoad_venom", name:"Dreamtoad Venom", tags:["UNIVERSAL","CONSUMABLE","POISON","RARE"], cost:"20+2D6" },
  eq_garlic: { id:"eq_garlic", name:"Garlic", tags:["UNIVERSAL"], cost:1 },
  eq_widows_kiss: { id:"eq_widows_kiss", name:"Widow’s Kiss", tags:["UNIVERSAL","CONSUMABLE","POISON","RARE"], cost:"25+D6" },

  eq_consumable_hunting_arrows: { id:"eq_consumable_hunting_arrows", name:"Consumable Hunting Arrows", tags:["UNIVERSAL","CONSUMABLE"], cost:"20+D6/25+3D6" },
  eq_sling_bullets: { id:"eq_sling_bullets", name:"Sling Bullets", tags:["UNIVERSAL","CONSUMABLE"], cost:"5/15" },

  eq_hunting_dog: { id:"eq_hunting_dog", name:"Hunting Dog", tags:["UNIVERSAL","ANIMAL"], cost:15, restrictions:"LEADERS and HEROES only." },
  eq_dire_cat: { id:"eq_dire_cat", name:"Dire Cat", tags:["UNIVERSAL","ANIMAL"], cost:20, restrictions:"LEADERS and HEROES only." },

  /* ---- Special materials (pg 30 subset) ----
     You said: “idk how tf I'm going to handle that yet”
     So: we keep these entries for later, BUT they are NOT surfaced as selectable equipment.
  */
  eq_sunsteel_upgrade: { id:"eq_sunsteel_upgrade", name:"Sunsteel (weapon material)", tags:["SPECIAL_MATERIAL","UPGRADE"], cost:"X" },
  eq_adamantite_upgrade: { id:"eq_adamantite_upgrade", name:"Adamantite (weapon material)", tags:["SPECIAL_MATERIAL","UPGRADE"], cost:"X 2" },
  eq_mithril_upgrade: { id:"eq_mithril_upgrade", name:"Mithril (weapon material)", tags:["SPECIAL_MATERIAL","UPGRADE"], cost:"X 3" },

  /* ---- Order of the Last Sun Unique Equipment ----
     Unique equipment should still be allowed at start (even if it’s rare elsewhere).
  */
  eq_solar_mace: { id:"eq_solar_mace", name:"Solar Mace", tags:["WEAPON","MELEE","UNIQUE"], cost:15, uniqueToFaction:"order_of_the_last_sun" },
  eq_sun_mask: { id:"eq_sun_mask", name:"Sun Mask", tags:["HELMET","UNIQUE"], cost:5, note:"Counts as a Helmet", uniqueToFaction:"order_of_the_last_sun" },
  eq_consecrated_stake: { id:"eq_consecrated_stake", name:"Consecrated Stake", tags:["WEAPON","MELEE","UNIQUE"], cost:10, uniqueToFaction:"order_of_the_last_sun" },
  eq_sunfire_phial: { id:"eq_sunfire_phial", name:"Sunfire Phial", tags:["UNIVERSAL","CONSUMABLE","UNIQUE"], cost:30, uniqueToFaction:"order_of_the_last_sun" },

  // OLS-only “silvered” stuff (kept as Unique for now)
  eq_silvered_melee: { id:"eq_silvered_melee", name:"Silvered Melee Weapon", tags:["UNIVERSAL","UPGRADE","UNIQUE"], cost:10, note:"+10 (OLS restricted)", uniqueToFaction:"order_of_the_last_sun" },
  eq_silvered_ammo: { id:"eq_silvered_ammo", name:"Silvered Ammunition", tags:["UNIVERSAL","AMMO","UNIQUE"], cost:15, uniqueToFaction:"order_of_the_last_sun" }
};

/* =========================================================
   ITEM-LEVEL restrictions (unit-specific availability)
   ========================================================= */

function patchItemRestrictions() {
  // Vigilants only: blastpowder guns
  EQUIPMENT_CATALOG.eq_blunderbuss.onlyUnits = ["ols_vigilant"];
  EQUIPMENT_CATALOG.eq_musket.onlyUnits = ["ols_vigilant"];
  EQUIPMENT_CATALOG.eq_long_rifle.onlyUnits = ["ols_vigilant"];

  // Man-at-Arms only: medium armor + halberd + spear
  EQUIPMENT_CATALOG.eq_medium_armor.onlyUnits = (EQUIPMENT_CATALOG.eq_medium_armor.onlyUnits || []).concat(["ols_man_at_arms"]);
  EQUIPMENT_CATALOG.eq_halberd.onlyUnits = (EQUIPMENT_CATALOG.eq_halberd.onlyUnits || []).concat(["ols_man_at_arms"]);
  EQUIPMENT_CATALOG.eq_spear.onlyUnits = (EQUIPMENT_CATALOG.eq_spear.onlyUnits || []).concat(["ols_man_at_arms","ols_dawner"]);

  // Dawners only: short bow
  EQUIPMENT_CATALOG.eq_short_bow.onlyUnits = (EQUIPMENT_CATALOG.eq_short_bow.onlyUnits || []).concat(["ols_dawner"]);

  // Solar Mace only for Vindicator & Dawnguard
  EQUIPMENT_CATALOG.eq_solar_mace.onlyUnits = ["ols_vindicator","ols_dawnguard"];

  // Dueling pistol: Justicar only
  EQUIPMENT_CATALOG.eq_dueling_pistol.onlyUnits = ["ols_justicar"];

  // Silvered items: Justicar and Purifiers only
  EQUIPMENT_CATALOG.eq_silvered_melee.onlyUnits = ["ols_justicar","ols_purifier"];
  EQUIPMENT_CATALOG.eq_silvered_ammo.onlyUnits = ["ols_justicar","ols_purifier"];
}
patchItemRestrictions();

/* =========================================================
   WARBANDS + ARCHETYPES
   ========================================================= */

const WARBANDS = [
  {
    id: "order_of_the_last_sun",
    name: "Order of the Last Sun",
    description: "A sanctioned strike force of Solmir. Archetype dictates allowed units.",
    archetypes: [
      {
        id: "purifier_conclave",
        name: "Purifier Conclave",
        description: "Militant hunters of corruption. Justicar-led, warhounds common.",
        leaders: ["ols_justicar", "ols_vindicator"],
        heroes: ["ols_purifier", "ols_chaplain", "ols_sunward_initiate"],
        henchmen: ["ols_warhound", "ols_man_at_arms", "ols_vigilant"],
        sellswords: ["sell_blade_for_hire"]
      },
      {
        id: "solmiric_clergy",
        name: "Solmiric Clergy",
        description: "Priests and attendants. Dawnfather leads; Dawnguard and Dawners support.",
        leaders: ["ols_dawnfather", "ols_vindicator"],
        heroes: ["ols_dawnguard", "ols_suntouched_vessel", "ols_sunward_initiate"],
        henchmen: ["ols_dawner", "ols_man_at_arms", "ols_vigilant"],
        sellswords: ["sell_blade_for_hire"]
      }
    ]
  }
];

/* =========================================================
   UNIT EQUIPMENT PROFILE (permissions / bans)
   ========================================================= */

const UNIT_EQUIP_PROFILE = {
  // default: can take equipment
  ols_warhound: { noEquipment:true },

  // vessel: no armor/helmet/shield
  ols_suntouched_vessel: { noHelmet:true, noArmor:true, noShield:true },

  // everyone else: default is allowed
};

function unitProfile(unitId){
  return UNIT_EQUIP_PROFILE[unitId] || {};
}

/* =========================================================
   STATE
   - each card has equipment stored by slot:
     equipment: { weaponIds:[], helmetId:"", armorId:"", shieldId:"", otherIds:[] }
   ========================================================= */

const STORAGE_KEY = "mirrored_city_builder_slots_v1";

let state = {
  name: "",
  warbandId: WARBANDS[0]?.id || "",
  archetypeId: "",
  leaderUnitId: "",
  cards: [] // cards do NOT include leader; leader is separate "leaderEquipment"
  // leaderEquipment is stored separately:
  // leaderEquipment: { weaponIds:[], helmetId:"", armorId:"", shieldId:"", otherIds:[] }
};

function ensureEquipObj(obj){
  if (!obj) return { weaponIds:[], helmetId:"", armorId:"", shieldId:"", otherIds:[] };

  // migrate from old shape (equipmentIds array)
  if (Array.isArray(obj.equipmentIds)){
    const slot = { weaponIds:[], helmetId:"", armorId:"", shieldId:"", otherIds:[] };
    for (const id of obj.equipmentIds){
      const eq = getEquip(id);
      const t = eq ? classifyEquip(eq) : "OTHER";
      if (t === "WEAPON") slot.weaponIds.push(id);
      else if (t === "HELMET" && !slot.helmetId) slot.helmetId = id;
      else if (t === "ARMOR" && !slot.armorId) slot.armorId = id;
      else if (t === "SHIELD" && !slot.shieldId) slot.shieldId = id;
      else slot.otherIds.push(id);
    }
    obj.equipment = slot;
    delete obj.equipmentIds;
  }

  if (!obj.equipment){
    obj.equipment = { weaponIds:[], helmetId:"", armorId:"", shieldId:"", otherIds:[] };
  } else {
    obj.equipment.weaponIds = Array.isArray(obj.equipment.weaponIds) ? obj.equipment.weaponIds : [];
    obj.equipment.otherIds  = Array.isArray(obj.equipment.otherIds) ? obj.equipment.otherIds : [];
    obj.equipment.helmetId  = obj.equipment.helmetId || "";
    obj.equipment.armorId   = obj.equipment.armorId || "";
    obj.equipment.shieldId  = obj.equipment.shieldId || "";
  }
  return obj.equipment;
}

function uid() {
  return Math.random().toString(16).slice(2) + Date.now().toString(16);
}
function byId(id){ return document.getElementById(id); }

function getWarbandBase() {
  return WARBANDS.find(w => w.id === state.warbandId) || WARBANDS[0] || null;
}
function getArchetype(warband) {
  if (!warband?.archetypes?.length) return null;
  return warband.archetypes.find(a => a.id === state.archetypeId) || warband.archetypes[0];
}
function getUnit(unitId) { return UNITS.find(u => u.id === unitId) || null; }
function getEquip(eid) { return EQUIPMENT_CATALOG[eid] || null; }

/* =========================================================
   EQUIPMENT CLASSIFICATION & STARTING FILTERS
   ========================================================= */

function classifyEquip(eq){
  const tags = eq.tags || [];

  // IMPORTANT: Helmets/Armor/Shields are distinct slots now (pg 26 tables)
  if (tags.includes("HELMET")) return "HELMET";
  if (tags.includes("SHIELD")) return "SHIELD";
  if (tags.includes("ARMOR"))  return "ARMOR";

  // Weapons (any combination from melee/ranged/blastpowder tables)
  if (tags.includes("WEAPON") || tags.includes("MELEE") || tags.includes("RANGED") || tags.includes("BLASTPOWDER")) {
    return "WEAPON";
  }

  // Everything else (universal equipment pages 27-31, excluding special materials)
  return "OTHER";
}

function isUniqueEquipment(eq){
  return (eq.tags || []).includes("UNIQUE") || !!eq.uniqueToFaction;
}

function isRare(eq){
  return (eq.tags || []).includes("RARE");
}

function isSpecialMaterial(eq){
  return (eq.tags || []).includes("SPECIAL_MATERIAL");
}

function isBlockedByStartingMode(eq){
  const mode = byId("creationMode")?.value || "starting";
  if (mode !== "starting") return false;

  // Rare items are not available at start, except Unique equipment
  if (isRare(eq) && !isUniqueEquipment(eq)) return true;

  return false;
}

function isFactionLocked(eq, unitFactionId){
  if (!eq.uniqueToFaction) return false;
  return eq.uniqueToFaction !== unitFactionId;
}

/* =========================================================
   ALLOWED EQUIPMENT PER UNIT PER SLOT
   ========================================================= */

function unitFactionId(){
  return state.warbandId;
}

function isEquipAllowedForUnit(unitId, eq, slotType){
  const prof = unitProfile(unitId);

  if (prof.noEquipment) return false;

  // no armor bits
  if (slotType === "HELMET" && prof.noHelmet) return false;
  if (slotType === "ARMOR"  && prof.noArmor) return false;
  if (slotType === "SHIELD" && prof.noShield) return false;

  // Faction lock for unique-to-faction items
  if (isFactionLocked(eq, unitFactionId())) return false;

  // starting-mode rarity filter
  if (isBlockedByStartingMode(eq)) return false;

  // special materials not selectable yet
  if (isSpecialMaterial(eq)) return false;

  // item-level unit restriction
  if (eq.onlyUnits && eq.onlyUnits.length && !eq.onlyUnits.includes(unitId)) return false;
  if (eq.notUnits && eq.notUnits.length && eq.notUnits.includes(unitId)) return false;

  // slot must match the equipment classification
  if (classifyEquip(eq) !== slotType) return false;

  // Universal equipment scope:
  // - OTHER slot should only include "UNIVERSAL" items + UNIQUE faction items (also tagged UNIVERSAL)
  if (slotType === "OTHER"){
    const tags = eq.tags || [];
    if (tags.includes("UNIVERSAL")) return true;
    // allow unique equipment that isn't tagged universal (safe fallback)
    if (isUniqueEquipment(eq)) return true;
    return false;
  }

  // Weapons/Helmet/Armor/Shield: any items in those tables
  return true;
}

function allowedEquipmentForUnitSlot(unitId, slotType){
  const out = [];
  for (const key in EQUIPMENT_CATALOG){
    const eq = EQUIPMENT_CATALOG[key];
    if (!eq) continue;
    if (!isEquipAllowedForUnit(unitId, eq, slotType)) continue;
    out.push(eq);
  }

  out.sort((a,b) => (a.name || "").localeCompare(b.name || ""));
  return out;
}

/* =========================================================
   COST PARSING
   ========================================================= */

function parseCost(costRaw){
  if (typeof costRaw === "number") {
    return { display:String(costRaw), base:costRaw, isVariable:false, isSplit:false };
  }
  if (typeof costRaw !== "string") {
    return { display:"—", base:0, isVariable:true, isSplit:false };
  }

  const raw = costRaw.trim();

  // Hero/Hench split "A/B"
  const split = raw.split("/").map(s => s.trim());
  if (split.length === 2) {
    const hero = parseCost(split[0]);
    const hench = parseCost(split[1]);
    return {
      display: raw,
      base: hero.base,
      isVariable: hero.isVariable || hench.isVariable,
      isSplit:true,
      heroBase: hero.base,
      henchBase: hench.base
    };
  }

  // "50+3D6" / "10+D6" etc -> base is leading number
  const m = raw.match(/^([0-9]+)\s*\+\s*(.+)$/i);
  if (m) {
    const base = parseInt(m[1], 10);
    return { display: raw, base: Number.isFinite(base)?base:0, isVariable:true, isSplit:false };
  }

  // plain number as string
  const n = parseInt(raw, 10);
  if (!Number.isNaN(n)) {
    return { display: raw, base:n, isVariable:false, isSplit:false };
  }

  return { display: raw, base:0, isVariable:true, isSplit:false };
}

function costForCardEquip(eq, cardKind){
  const parsed = parseCost(eq.cost);
  if (parsed.isSplit){
    const isHeroish = (cardKind === "LEADER" || cardKind === "HERO");
    const base = isHeroish ? (parsed.heroBase ?? 0) : (parsed.henchBase ?? 0);
    return { base, display: parsed.display, isVariable: parsed.isVariable };
  }
  return { base: parsed.base, display: parsed.display, isVariable: parsed.isVariable };
}

/* =========================================================
   SLOT UTIL
   ========================================================= */

function getCardEquip(card){
  // leader uses separate stored object
  if (card.kind === "LEADER"){
    state.leaderEquipment = state.leaderEquipment || { weaponIds:[], helmetId:"", armorId:"", shieldId:"", otherIds:[] };
    return state.leaderEquipment;
  }
  ensureEquipObj(card);
  return card.equipment;
}

function slotCounts(equipObj){
  return {
    WEAPON: (equipObj.weaponIds || []).length,
    HELMET: equipObj.helmetId ? 1 : 0,
    ARMOR: equipObj.armorId ? 1 : 0,
    SHIELD: equipObj.shieldId ? 1 : 0,
    OTHER: (equipObj.otherIds || []).length
  };
}

function canAddToSlot(equipObj, slotType){
  const counts = slotCounts(equipObj);
  return counts[slotType] < RULES.equipSlots[slotType];
}

function addEquipToSlot(equipObj, slotType, eqId){
  if (!eqId) return false;
  if (!canAddToSlot(equipObj, slotType)) return false;

  if (slotType === "WEAPON"){
    if (!equipObj.weaponIds.includes(eqId)) equipObj.weaponIds.push(eqId);
    return true;
  }
  if (slotType === "OTHER"){
    if (!equipObj.otherIds.includes(eqId)) equipObj.otherIds.push(eqId);
    return true;
  }
  if (slotType === "HELMET"){
    equipObj.helmetId = eqId;
    return true;
  }
  if (slotType === "ARMOR"){
    equipObj.armorId = eqId;
    return true;
  }
  if (slotType === "SHIELD"){
    equipObj.shieldId = eqId;
    return true;
  }
  return false;
}

function removeEquip(equipObj, eqId){
  if (!eqId) return;
  equipObj.weaponIds = (equipObj.weaponIds || []).filter(x => x !== eqId);
  equipObj.otherIds  = (equipObj.otherIds || []).filter(x => x !== eqId);
  if (equipObj.helmetId === eqId) equipObj.helmetId = "";
  if (equipObj.armorId === eqId)  equipObj.armorId = "";
  if (equipObj.shieldId === eqId) equipObj.shieldId = "";
}

function allEquipIds(equipObj){
  const ids = [];
  for (const x of (equipObj.weaponIds || [])) ids.push(x);
  if (equipObj.helmetId) ids.push(equipObj.helmetId);
  if (equipObj.armorId) ids.push(equipObj.armorId);
  if (equipObj.shieldId) ids.push(equipObj.shieldId);
  for (const x of (equipObj.otherIds || [])) ids.push(x);
  return ids;
}

/* =========================================================
   COST TOTALS
   - equipment costs are per Stat Card
   - variable costs count base only, but we show "+" in UI
   ========================================================= */

function equipmentTotalForCard(equipObj, cardKind){
  let sum = 0;
  let hasVariable = false;

  for (const id of allEquipIds(equipObj)){
    const eq = getEquip(id);
    if (!eq) continue;
    const c = costForCardEquip(eq, cardKind);
    sum += c.base;
    if (c.isVariable) hasVariable = true;
  }
  return { sum, hasVariable };
}

function cardCost(card){
  const unit = getUnit(card.unitId);
  if (!unit) return { sum:0, hasVariable:false };

  let count = 1;
  if (card.kind === "HENCHMAN") count = card.count || 1;

  const base = (unit.cost || 0) * count;
  const eq = equipmentTotalForCard(getCardEquip(card), card.kind);
  return { sum: base + eq.sum, hasVariable: eq.hasVariable };
}

function totalLumens(){
  let total = 0;
  let hasVariable = false;

  // leader
  const leader = getUnit(state.leaderUnitId);
  if (leader){
    total += (leader.cost || 0);
    const eq = equipmentTotalForCard(getCardEquip({kind:"LEADER"}), "LEADER");
    total += eq.sum;
    if (eq.hasVariable) hasVariable = true;
  }

  for (const c of state.cards){
    const cc = cardCost(c);
    total += cc.sum;
    if (cc.hasVariable) hasVariable = true;
  }

  return { total, hasVariable };
}

/* =========================================================
   LISTBUILDING POOLS
   ========================================================= */

function allowedLeaderIds(warbandBase){
  const arch = getArchetype(warbandBase);
  return arch ? (arch.leaders || []).slice() : (warbandBase.leaders || []).slice();
}
function allowedUnitIdsForKind(warbandBase, kind){
  const arch = getArchetype(warbandBase);
  if (arch){
    if (kind === "HERO") return arch.heroes.slice();
    if (kind === "HENCHMAN") return arch.henchmen.slice();
    return [];
  }
  if (kind === "HERO") return (warbandBase.heroes || []).slice();
  if (kind === "HENCHMAN") return (warbandBase.henchmen || []).slice();
  return [];
}

/* =========================================================
   VALIDATION
   ========================================================= */

function clampInt(n, min, max){
  const x = parseInt(n, 10);
  if (Number.isNaN(x)) return min;
  return Math.max(min, Math.min(max, x));
}

function validate(){
  const errs = [];
  const warns = [];

  const warbandBase = getWarbandBase();
  const arch = getArchetype(warbandBase);

  const hasLeader = !!state.leaderUnitId;

  // NOW leader counts as a stat card
  const filledNonLeaderCards = state.cards.length;
  const filledCards = (hasLeader ? 1 : 0) + filledNonLeaderCards;

  const hasHenchmanCard = state.cards.some(c => c.kind === "HENCHMAN");
  const hasOneMore = filledCards >= 3; // leader+hench +1 total cards (leader counts)

  const heroCardsCount = state.cards.filter(c => c.kind === "HERO").length;
  const heroesIncludingLeader = (hasLeader ? 1 : 0) + heroCardsCount;

  let hasSellsword = false;
  for (const c of state.cards){
    const u = getUnit(c.unitId);
    if (u && u.type === "SELLSWORD") hasSellsword = true;
  }

  const spentObj = totalLumens();
  const spent = spentObj.total;

  if (spent > RULES.startingLumens) errs.push(`Over budget: spent ${spent} / ${RULES.startingLumens} lumens.`);
  if (filledCards > RULES.startingStatCardsMax) errs.push(`Too many Stat Cards: ${filledCards} / ${RULES.startingStatCardsMax} (Leader counts).`);
  if (filledCards < RULES.startingStatCardsMinFilled) errs.push(`Not enough Stat Cards filled: ${filledCards} / ${RULES.startingStatCardsMinFilled} required at creation (Leader counts).`);
  if (!hasLeader) errs.push("Starting warband must include a Leader.");
  if (arch == null && (warbandBase?.archetypes?.length)) errs.push("This warband requires selecting an Archetype.");
  if (!hasHenchmanCard) errs.push("Starting warband must include at least one Henchman Card.");
  if (!hasOneMore) errs.push("Starting warband must include Leader + Henchman + one additional Stat Card (minimum 3 cards; Leader counts).");
  if (heroesIncludingLeader > RULES.startingMaxHeroesIncludingLeader) errs.push(`Too many Heroes (including Leader): ${heroesIncludingLeader} / ${RULES.startingMaxHeroesIncludingLeader}.`);
  if (!RULES.sellswordsAllowedAtCreation && hasSellsword) errs.push("Sellswords cannot be hired during warband creation.");

  if (hasLeader){
    const allowedLeaders = allowedLeaderIds(warbandBase);
    if (!allowedLeaders.includes(state.leaderUnitId)){
      const leaderUnit = getUnit(state.leaderUnitId);
      errs.push(`Leader not allowed for selected archetype: ${leaderUnit ? leaderUnit.name : state.leaderUnitId}.`);
    }
  }

  // card unit legality + hench count + equipment legality/slot caps
  for (const c of state.cards){
    const u = getUnit(c.unitId);
    if (c.unitId){
      const allowedIds = allowedUnitIdsForKind(warbandBase, c.kind);
      if (!allowedIds.includes(c.unitId)){
        errs.push(`Invalid unit for this archetype/card type: ${(u?.name)||c.unitId} on a ${c.kind} card.`);
      }
    }

    if (c.kind === "HENCHMAN" && u){
      const isHorde = (u.tags || []).includes("HORDE");
      const max = isHorde ? 4 : 3;
      const count = clampInt(c.count, 1, max);
      if (count !== c.count){
        errs.push(`${u.name}: Henchman count must be 1–${max}${isHorde ? " (HORDE)" : ""}.`);
      }
    }

    // slot caps
    const eqObj = getCardEquip(c);
    const counts = slotCounts(eqObj);
    for (const slot of ["WEAPON","HELMET","ARMOR","SHIELD","OTHER"]){
      if (counts[slot] > RULES.equipSlots[slot]){
        errs.push(`${u?.name || "Card"}: too many items in ${slot} slot (${counts[slot]} / ${RULES.equipSlots[slot]}).`);
      }
    }

    // legality per item
    for (const id of allEquipIds(eqObj)){
      const eq = getEquip(id);
      if (!eq){
        warns.push(`${u?.name || "Card"}: unknown equipment id (${id}).`);
        continue;
      }
      const slot = classifyEquip(eq);
      if (!isEquipAllowedForUnit(c.unitId, eq, slot)){
        errs.push(`${u?.name || "Unit"}: cannot take ${eq.name}.`);
      }
    }
  }

  // leader equipment legality + slot caps
  if (hasLeader){
    const eqObj = getCardEquip({kind:"LEADER"});
    const counts = slotCounts(eqObj);
    for (const slot of ["WEAPON","HELMET","ARMOR","SHIELD","OTHER"]){
      if (counts[slot] > RULES.equipSlots[slot]){
        errs.push(`Leader: too many items in ${slot} slot (${counts[slot]} / ${RULES.equipSlots[slot]}).`);
      }
    }
    for (const id of allEquipIds(eqObj)){
      const eq = getEquip(id);
      if (!eq){
        warns.push(`Leader: unknown equipment id (${id}).`);
        continue;
      }
      const slot = classifyEquip(eq);
      if (!isEquipAllowedForUnit(state.leaderUnitId, eq, slot)){
        errs.push(`${getUnit(state.leaderUnitId)?.name || "Leader"}: cannot take ${eq.name}.`);
      }
    }
  }

  return {
    errs,
    warns,
    meta: {
      hasLeader,
      hasHenchmanCard,
      hasOneMore,
      meetsMinCards: filledCards >= RULES.startingStatCardsMinFilled,
      noSellswords: !hasSellsword,
      filledCards,
      heroesIncludingLeader,
      spent,
      spentHasVariable: spentObj.hasVariable
    }
  };
}

/* =========================================================
   RENDER
   ========================================================= */

function render(){
  byId("rosterName").value = state.name || "";

  const warbandBase = getWarbandBase();

  // warband select
  const wbSel = byId("warbandSelect");
  wbSel.innerHTML = "";
  for (const w of WARBANDS){
    const opt = document.createElement("option");
    opt.value = w.id;
    opt.textContent = w.name;
    wbSel.appendChild(opt);
  }
  wbSel.value = state.warbandId;
  byId("warbandDesc").textContent = warbandBase?.description || "";

  // archetype select
  const archSel = byId("archetypeSelect");
  archSel.innerHTML = "";
  const archetypes = warbandBase?.archetypes || [];
  if (!archetypes.length){
    archSel.disabled = true;
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "— (No archetypes) —";
    archSel.appendChild(opt);
    byId("archetypeDesc").textContent = "";
    state.archetypeId = "";
  } else {
    archSel.disabled = false;
    if (!state.archetypeId) state.archetypeId = archetypes[0].id;
    for (const a of archetypes){
      const opt = document.createElement("option");
      opt.value = a.id;
      opt.textContent = a.name;
      archSel.appendChild(opt);
    }
    archSel.value = state.archetypeId;
    byId("archetypeDesc").textContent = (getArchetype(warbandBase)?.description) || "";
  }

  // leader select
  const leaderSel = byId("leaderSelect");
  leaderSel.innerHTML = "";
  const ph = document.createElement("option");
  ph.value = "";
  ph.textContent = "— Select Leader —";
  leaderSel.appendChild(ph);

  const leaderIds = allowedLeaderIds(warbandBase);
  for (const id of leaderIds){
    const u = getUnit(id);
    if (!u) continue;
    const opt = document.createElement("option");
    opt.value = id;
    opt.textContent = `${u.name} (${u.cost} lumens)`;
    leaderSel.appendChild(opt);
  }
  leaderSel.value = state.leaderUnitId || "";

  // ensure leader equipment object exists if leader selected
  if (state.leaderUnitId){
    state.leaderEquipment = state.leaderEquipment || { weaponIds:[], helmetId:"", armorId:"", shieldId:"", otherIds:[] };
  } else {
    delete state.leaderEquipment;
  }

  // cards UI
  const cardsEl = byId("cards");
  cardsEl.innerHTML = "";

  // Leader stat card UI (counts against stat cards)
  if (state.leaderUnitId){
    cardsEl.appendChild(renderLeaderStatCard());
  }

  for (const c of state.cards){
    cardsEl.appendChild(renderStatCard(c, warbandBase));
  }

  // Summary + messages
  const v = validate();
  renderSummary(v);

  byId("jsonPreview").value = JSON.stringify(safeExportState(), null, 2);

  save();
}

function renderLeaderStatCard(){
  const wrap = document.createElement("div");
  wrap.className = "card";

  const leaderUnit = getUnit(state.leaderUnitId);
  const leaderCard = { kind:"LEADER", unitId: state.leaderUnitId, count:1 };
  const cc = (() => {
    // leader cost includes equipment like a normal card
    const eq = equipmentTotalForCard(getCardEquip(leaderCard), "LEADER");
    const base = leaderUnit ? (leaderUnit.cost || 0) : 0;
    return { sum: base + eq.sum, hasVariable: eq.hasVariable };
  })();

  wrap.innerHTML = `
    <div class="card-top">
      <div class="card-title">
        <span>LEADER Stat Card</span>
        <span class="pill">Counts as 1 Card</span>
        <span class="pill">Cost: ${cc.sum}${cc.hasVariable ? "+" : ""}</span>
      </div>
      <button class="noPrint" disabled>Leader</button>
    </div>

    <div class="muted">Leader: <strong>${leaderUnit ? leaderUnit.name : "—"}</strong></div>

    <div class="slotGrid" id="slots_leader"></div>
  `;

  const slotsHost = wrap.querySelector("#slots_leader");
  renderEquipmentSlotsUI(slotsHost, leaderCard, "LEADER");

  return wrap;
}

function renderStatCard(card, warbandBase){
  ensureEquipObj(card);

  const wrap = document.createElement("div");
  wrap.className = "card";

  const kindLabel = card.kind === "HERO" ? "HERO" : "HENCHMAN";
  const unit = getUnit(card.unitId);
  const isHorde = unit && (unit.tags || []).includes("HORDE");
  const maxCount = (card.kind === "HENCHMAN") ? (isHorde ? 4 : 3) : 1;

  const cc = cardCost(card);

  wrap.innerHTML = `
    <div class="card-top">
      <div class="card-title">
        <span>${kindLabel} Card</span>
        ${isHorde ? `<span class="pill warn">HORDE</span>` : ""}
        <span class="pill">Cost: ${cc.sum}${cc.hasVariable ? "+" : ""}</span>
        ${unit?.limit ? `<span class="pill">${unit.limit}</span>` : ""}
      </div>
      <button class="noPrint" id="rm_${card.id}">Remove</button>
    </div>

    <div class="row two">
      <div>
        <label>Unit</label>
        <select id="unit_${card.id}"></select>
      </div>
      <div>
        <label>Count ${card.kind === "HENCHMAN" ? `(1–${maxCount})` : ""}</label>
        <input id="count_${card.id}" type="number" min="1" max="${maxCount}" ${card.kind === "HENCHMAN" ? "" : "disabled"} />
        <div class="tiny">${card.kind === "HENCHMAN" ? (isHorde ? "HORDE henchmen can be 1–4." : "Henchmen are 1–3.") : "Heroes are always 1 model."}</div>
      </div>
    </div>

    <div class="slotGrid" id="slots_${card.id}"></div>
  `;

  // remove
  wrap.querySelector(`#rm_${card.id}`).addEventListener("click", () => {
    state.cards = state.cards.filter(c => c.id !== card.id);
    render();
  });

  // unit dropdown
  const unitSel = wrap.querySelector(`#unit_${card.id}`);
  unitSel.innerHTML = "";
  const allowedIds = allowedUnitIdsForKind(warbandBase, card.kind);

  const ph = document.createElement("option");
  ph.value = "";
  ph.textContent = "— Select Unit —";
  unitSel.appendChild(ph);

  for (const id of allowedIds){
    const u = getUnit(id);
    if (!u) continue;
    const opt = document.createElement("option");
    opt.value = id;
    opt.textContent = `${u.name} (${u.cost} lumens${(u.tags||[]).includes("HORDE") ? ", HORDE" : ""}${u.type==="SELLSWORD" ? ", SELLSWORD" : ""})`;
    unitSel.appendChild(opt);
  }

  unitSel.value = card.unitId || "";
  unitSel.addEventListener("change", () => {
    card.unitId = unitSel.value;

    // adjust count bounds
    const u = getUnit(card.unitId);
    const horde = u && (u.tags||[]).includes("HORDE");
    const max = (card.kind === "HENCHMAN") ? (horde ? 4 : 3) : 1;
    card.count = clampInt(card.count || 1, 1, max);

    // prune illegal equipment (by slot)
    pruneIllegalEquipmentForCard(card);

    render();
  });

  // count
  const countEl = wrap.querySelector(`#count_${card.id}`);
  if (card.kind === "HENCHMAN"){
    countEl.value = card.count || 1;
    countEl.addEventListener("input", () => {
      const u = getUnit(card.unitId);
      const horde = u && (u.tags||[]).includes("HORDE");
      const max = horde ? 4 : 3;
      card.count = clampInt(countEl.value, 1, max);
      render();
    });
  } else {
    countEl.value = 1;
    card.count = 1;
  }

  // equipment slots
  const slotsHost = wrap.querySelector(`#slots_${card.id}`);
  renderEquipmentSlotsUI(slotsHost, card, card.kind);

  return wrap;
}

function pruneIllegalEquipmentForCard(card){
  const unitId = card.unitId;
  const eqObj = getCardEquip(card);

  // If no unit yet, clear
  if (!unitId){
    eqObj.weaponIds = [];
    eqObj.otherIds = [];
    eqObj.helmetId = "";
    eqObj.armorId = "";
    eqObj.shieldId = "";
    return;
  }

  // filter each slot by current allowlist
  const allowedWeapons = new Set(allowedEquipmentForUnitSlot(unitId, "WEAPON").map(e=>e.id));
  const allowedHelmets = new Set(allowedEquipmentForUnitSlot(unitId, "HELMET").map(e=>e.id));
  const allowedArmor   = new Set(allowedEquipmentForUnitSlot(unitId, "ARMOR").map(e=>e.id));
  const allowedShield  = new Set(allowedEquipmentForUnitSlot(unitId, "SHIELD").map(e=>e.id));
  const allowedOther   = new Set(allowedEquipmentForUnitSlot(unitId, "OTHER").map(e=>e.id));

  eqObj.weaponIds = (eqObj.weaponIds || []).filter(id => allowedWeapons.has(id)).slice(0, RULES.equipSlots.WEAPON);
  eqObj.otherIds  = (eqObj.otherIds || []).filter(id => allowedOther.has(id)).slice(0, RULES.equipSlots.OTHER);

  if (eqObj.helmetId && !allowedHelmets.has(eqObj.helmetId)) eqObj.helmetId = "";
  if (eqObj.armorId && !allowedArmor.has(eqObj.armorId)) eqObj.armorId = "";
  if (eqObj.shieldId && !allowedShield.has(eqObj.shieldId)) eqObj.shieldId = "";
}

function renderEquipmentSlotsUI(host, card, cardKind){
  host.innerHTML = "";

  const unitId = (cardKind === "LEADER") ? state.leaderUnitId : card.unitId;
  const eqObj = getCardEquip(card);

  // if no unit selected, show disabled slots
  const noUnit = !unitId;

  const slotDefs = [
    { key:"WEAPON", label:"Weapons", hint:`Up to ${RULES.equipSlots.WEAPON} (Melee/Ranged/Blastpowder tables)`, multi:true },
    { key:"HELMET", label:"Helmet", hint:`${RULES.equipSlots.HELMET} (Helmet table)`, multi:false },
    { key:"ARMOR",  label:"Armor",  hint:`${RULES.equipSlots.ARMOR} (Armor table)`, multi:false },
    { key:"SHIELD", label:"Shield", hint:`${RULES.equipSlots.SHIELD} (Shield table)`, multi:false },
    { key:"OTHER",  label:"Everything Else", hint:`Up to ${RULES.equipSlots.OTHER} (Universal equipment; no Special Materials)`, multi:true }
  ];

  for (const s of slotDefs){
    const box = document.createElement("div");
    box.className = "slotBox";

    const counts = slotCounts(eqObj);
    const max = RULES.equipSlots[s.key];
    const count = counts[s.key];

    // unit-level bans
    const prof = unitId ? unitProfile(unitId) : {};
    const banned =
      (s.key === "HELMET" && prof.noHelmet) ||
      (s.key === "ARMOR"  && prof.noArmor) ||
      (s.key === "SHIELD" && prof.noShield) ||
      (prof.noEquipment);

    box.innerHTML = `
      <div class="slotHdr">
        <strong>${s.label}</strong>
        <span>${count} / ${max}</span>
      </div>
      <div class="tiny">${s.hint}</div>

      <div class="slotAddRow">
        <div>
          <label>Add</label>
          <select id="sel_${s.key}_${cardKind}_${card.id || "leader"}">
            <option value="">— Choose —</option>
          </select>
          <div class="tiny" id="help_${s.key}_${cardKind}_${card.id || "leader"}"></div>
        </div>
        <button class="noPrint" id="btn_${s.key}_${cardKind}_${card.id || "leader"}">Add</button>
      </div>

      <div class="equipList" id="list_${s.key}_${cardKind}_${card.id || "leader"}"></div>
    `;

    host.appendChild(box);

    const sel = box.querySelector(`#sel_${s.key}_${cardKind}_${card.id || "leader"}`);
    const btn = box.querySelector(`#btn_${s.key}_${cardKind}_${card.id || "leader"}`);
    const help = box.querySelector(`#help_${s.key}_${cardKind}_${card.id || "leader"}`);

    // disabled state
    if (noUnit){
      sel.disabled = true;
      btn.disabled = true;
      help.textContent = "Select a unit to see available equipment.";
      renderSlotChips(box.querySelector(`#list_${s.key}_${cardKind}_${card.id || "leader"}`), card, cardKind, s.key);
      continue;
    }

    if (banned){
      sel.disabled = true;
      btn.disabled = true;
      help.textContent = "This unit cannot take items in this slot.";
      renderSlotChips(box.querySelector(`#list_${s.key}_${cardKind}_${card.id || "leader"}`), card, cardKind, s.key);
      continue;
    }

    // populate options for this slot
    const allowed = allowedEquipmentForUnitSlot(unitId, s.key);

    // hide already-chosen single-slot item from options (helmet/armor/shield)
    const chosenSingle = (s.key === "HELMET" ? eqObj.helmetId :
                          s.key === "ARMOR"  ? eqObj.armorId :
                          s.key === "SHIELD" ? eqObj.shieldId : "");

    const filtered = allowed.filter(eq => {
      if (!eq) return false;
      if (!s.multi && chosenSingle && eq.id === chosenSingle) return false;
      if (s.key === "WEAPON" && (eqObj.weaponIds || []).includes(eq.id)) return false;
      if (s.key === "OTHER"  && (eqObj.otherIds || []).includes(eq.id)) return false;
      return true;
    });

    if (!filtered.length){
      sel.disabled = true;
      btn.disabled = true;
      help.textContent = "No available items for this slot (or filtered by Starting mode).";
      renderSlotChips(box.querySelector(`#list_${s.key}_${cardKind}_${card.id || "leader"}`), card, cardKind, s.key);
      continue;
    }

    for (const eq of filtered){
      const c = costForCardEquip(eq, cardKind === "LEADER" ? "LEADER" : cardKind);
      const bits = [];
      if (isUniqueEquipment(eq)) bits.push("Unique");
      if (isRare(eq)) bits.push("Rare");
      if (c.isVariable) bits.push("var");

      const opt = document.createElement("option");
      opt.value = eq.id;
      opt.textContent = `${eq.name} (${c.display}${bits.length ? " • " + bits.join(", ") : ""})`;
      sel.appendChild(opt);
    }

    // add behavior (enforce slot caps)
    btn.disabled = !canAddToSlot(eqObj, s.key);
    help.textContent = btn.disabled ? "Slot is full." : "Choose an item and click Add.";

    btn.addEventListener("click", () => {
      const id = sel.value;
      if (!id) return;
      if (!canAddToSlot(eqObj, s.key)) return;

      addEquipToSlot(eqObj, s.key, id);

      // after adding, if this is a single-slot, it becomes "full"
      render();
    });

    renderSlotChips(box.querySelector(`#list_${s.key}_${cardKind}_${card.id || "leader"}`), card, cardKind, s.key);
  }
}

function renderSlotChips(container, card, cardKind, slotKey){
  const eqObj = getCardEquip(card);

  let ids = [];
  if (slotKey === "WEAPON") ids = (eqObj.weaponIds || []).slice();
  else if (slotKey === "OTHER") ids = (eqObj.otherIds || []).slice();
  else if (slotKey === "HELMET" && eqObj.helmetId) ids = [eqObj.helmetId];
  else if (slotKey === "ARMOR" && eqObj.armorId) ids = [eqObj.armorId];
  else if (slotKey === "SHIELD" && eqObj.shieldId) ids = [eqObj.shieldId];

  container.innerHTML = "";
  if (!ids.length){
    const t = document.createElement("div");
    t.className = "tiny";
    t.textContent = "None selected.";
    container.appendChild(t);
    return;
  }

  for (const id of ids){
    const eq = getEquip(id);
    const chip = document.createElement("div");
    chip.className = "equipChip";

    const c = eq ? costForCardEquip(eq, cardKind === "LEADER" ? "LEADER" : cardKind) : { display:"—", base:0, isVariable:true };
    const meta = [];
    if (eq && isUniqueEquipment(eq)) meta.push("Unique");
    if (eq && isRare(eq)) meta.push("Rare");
    if (c.isVariable) meta.push("var");

    chip.innerHTML = `
      <span>${eq ? eq.name : id}</span>
      <span class="tagMini">${eq ? `${c.display}${meta.length ? " • " + meta.join(", ") : ""}` : ""}</span>
      <span class="x" title="Remove">×</span>
    `;

    chip.querySelector(".x").addEventListener("click", () => {
      removeEquip(eqObj, id);
      render();
    });

    container.appendChild(chip);
  }
}

/* =========================================================
   SUMMARY UI
   ========================================================= */

function setReqPill(id, ok){
  const el = byId(id);
  el.classList.remove("good","bad");
  el.classList.add(ok ? "good" : "bad");
}

function renderSummary(v){
  const spent = v.meta.spent;
  const remaining = RULES.startingLumens - spent;

  byId("lumensText").textContent = `${spent}${v.meta.spentHasVariable ? "+" : ""} / ${RULES.startingLumens}`;
  byId("lumensSub").textContent = `Remaining: ${remaining}${v.meta.spentHasVariable ? " (some costs are variable)" : ""}`;

  const lumBox = byId("statLumens");
  lumBox.classList.toggle("badBorder", remaining < 0);
  lumBox.classList.toggle("goodBorder", remaining >= 0);

  byId("cardsText").textContent = `${v.meta.filledCards} / ${RULES.startingStatCardsMax}`;
  byId("cardsSub").textContent = `Minimum at creation: ${RULES.startingStatCardsMinFilled}`;

  const cardsBox = byId("statCards");
  cardsBox.classList.toggle("badBorder", v.meta.filledCards > RULES.startingStatCardsMax || v.meta.filledCards < RULES.startingStatCardsMinFilled);
  cardsBox.classList.toggle("goodBorder", v.meta.filledCards >= RULES.startingStatCardsMinFilled && v.meta.filledCards <= RULES.startingStatCardsMax);

  byId("heroesText").textContent = `${v.meta.heroesIncludingLeader} / ${RULES.startingMaxHeroesIncludingLeader}`;
  const heroBox = byId("statHeroes");
  heroBox.classList.toggle("badBorder", v.meta.heroesIncludingLeader > RULES.startingMaxHeroesIncludingLeader);
  heroBox.classList.toggle("goodBorder", v.meta.heroesIncludingLeader <= RULES.startingMaxHeroesIncludingLeader);

  setReqPill("reqLeader", v.meta.hasLeader);
  setReqPill("reqHench", v.meta.hasHenchmanCard);
  setReqPill("reqOneMore", v.meta.hasOneMore);
  setReqPill("reqMinCards", v.meta.meetsMinCards);
  setReqPill("reqNoSells", v.meta.noSellswords);

  const box = byId("messages");
  box.innerHTML = "";

  if (v.errs.length === 0 && v.warns.length === 0){
    const ok = document.createElement("div");
    ok.className = "okBox";
    ok.textContent = "Looks good so far. This roster passes the starting-warband checks.";
    box.appendChild(ok);
  } else {
    for (const e of v.errs){
      const el = document.createElement("div");
      el.className = "err";
      el.textContent = e;
      box.appendChild(el);
    }
    for (const w of v.warns){
      const el = document.createElement("div");
      el.className = "warnBox";
      el.textContent = w;
      box.appendChild(el);
    }
  }
}

/* =========================================================
   EVENTS
   ========================================================= */

byId("rosterName").addEventListener("input", (e) => {
  state.name = e.target.value;
  render();
});

byId("warbandSelect").addEventListener("change", (e) => {
  state.warbandId = e.target.value;
  state.archetypeId = "";
  state.leaderUnitId = "";
  state.cards = [];
  delete state.leaderEquipment;
  render();
});

byId("archetypeSelect").addEventListener("change", (e) => {
  state.archetypeId = e.target.value;
  state.leaderUnitId = "";
  state.cards = [];
  delete state.leaderEquipment;
  render();
});

byId("leaderSelect").addEventListener("change", (e) => {
  state.leaderUnitId = e.target.value;

  // reset leader equipment when leader changes
  if (state.leaderUnitId){
    state.leaderEquipment = { weaponIds:[], helmetId:"", armorId:"", shieldId:"", otherIds:[] };
  } else {
    delete state.leaderEquipment;
  }

  render();
});

byId("btnAddHero").addEventListener("click", () => {
  state.cards.push({ id: uid(), kind: "HERO", unitId: "", count: 1, equipment: { weaponIds:[], helmetId:"", armorId:"", shieldId:"", otherIds:[] } });
  render();
});

byId("btnAddHench").addEventListener("click", () => {
  state.cards.push({ id: uid(), kind: "HENCHMAN", unitId: "", count: 1, equipment: { weaponIds:[], helmetId:"", armorId:"", shieldId:"", otherIds:[] } });
  render();
});

byId("btnReset").addEventListener("click", () => {
  if (!confirm("Reset roster? This clears saved data in this browser.")) return;
  localStorage.removeItem(STORAGE_KEY);
  state = {
    name: "",
    warbandId: WARBANDS[0]?.id || "",
    archetypeId: "",
    leaderUnitId: "",
    cards: []
  };
  render();
});

byId("btnPrint").addEventListener("click", () => window.print());
byId("btnExport").addEventListener("click", () => exportRoster());
byId("btnImport").addEventListener("click", () => importRoster());

/* =========================================================
   SAVE / LOAD / EXPORT
   ========================================================= */

function safeExportState(){
  // keep data compact + future-proof
  return {
    version: 2,
    roster: {
      name: state.name,
      warbandId: state.warbandId,
      archetypeId: state.archetypeId,
      leaderUnitId: state.leaderUnitId,
      leaderEquipment: state.leaderEquipment || { weaponIds:[], helmetId:"", armorId:"", shieldId:"", otherIds:[] },
      cards: state.cards.map(c => ({
        id: c.id,
        kind: c.kind,
        unitId: c.unitId,
        count: c.count,
        equipment: ensureEquipObj(c) && c.equipment
      }))
    }
  };
}

function applyImported(obj){
  if (!obj || !obj.roster) throw new Error("Invalid roster format.");

  const r = obj.roster;
  state.name = r.name || "";
  state.warbandId = r.warbandId || (WARBANDS[0]?.id || "");
  state.archetypeId = r.archetypeId || "";
  state.leaderUnitId = r.leaderUnitId || "";

  // leader equipment
  state.leaderEquipment = r.leaderEquipment || { weaponIds:[], helmetId:"", armorId:"", shieldId:"", otherIds:[] };

  // cards
  const importedCards = Array.isArray(r.cards) ? r.cards : [];
  state.cards = importedCards.map(c => {
    const card = {
      id: c.id || uid(),
      kind: c.kind,
      unitId: c.unitId || "",
      count: c.count || 1,
      equipment: c.equipment || { weaponIds:[], helmetId:"", armorId:"", shieldId:"", otherIds:[] }
    };
    ensureEquipObj(card);
    return card;
  });

  // prune illegal equipment after load
  if (!state.leaderUnitId) delete state.leaderEquipment;
  if (state.leaderUnitId){
    // prune leader
    const fakeLeaderCard = { kind:"LEADER", unitId: state.leaderUnitId };
    pruneIllegalEquipmentForLeader(fakeLeaderCard);
  }
  for (const c of state.cards){
    pruneIllegalEquipmentForCard(c);
  }
}

function pruneIllegalEquipmentForLeader(){
  const unitId = state.leaderUnitId;
  if (!unitId || !state.leaderEquipment) return;

  const eqObj = state.leaderEquipment;

  const allowedWeapons = new Set(allowedEquipmentForUnitSlot(unitId, "WEAPON").map(e=>e.id));
  const allowedHelmets = new Set(allowedEquipmentForUnitSlot(unitId, "HELMET").map(e=>e.id));
  const allowedArmor   = new Set(allowedEquipmentForUnitSlot(unitId, "ARMOR").map(e=>e.id));
  const allowedShield  = new Set(allowedEquipmentForUnitSlot(unitId, "SHIELD").map(e=>e.id));
  const allowedOther   = new Set(allowedEquipmentForUnitSlot(unitId, "OTHER").map(e=>e.id));

  eqObj.weaponIds = (eqObj.weaponIds || []).filter(id => allowedWeapons.has(id)).slice(0, RULES.equipSlots.WEAPON);
  eqObj.otherIds  = (eqObj.otherIds || []).filter(id => allowedOther.has(id)).slice(0, RULES.equipSlots.OTHER);

  if (eqObj.helmetId && !allowedHelmets.has(eqObj.helmetId)) eqObj.helmetId = "";
  if (eqObj.armorId && !allowedArmor.has(eqObj.armorId)) eqObj.armorId = "";
  if (eqObj.shieldId && !allowedShield.has(eqObj.shieldId)) eqObj.shieldId = "";
}

function save(){
  try{
    localStorage.setItem(STORAGE_KEY, JSON.stringify(safeExportState()));
  }catch{}
}

function load(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return false;
    applyImported(JSON.parse(raw));
    return true;
  }catch{
    return false;
  }
}

function exportRoster(){
  const obj = safeExportState();
  const json = JSON.stringify(obj, null, 2);
  const blob = new Blob([json], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = (state.name ? state.name.replace(/[^\w\- ]+/g,"").trim().replace(/\s+/g,"_") : "mirrored_city_roster") + ".json";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function importRoster(){
  const input = document.createElement("input");
  input.type = "file";
  input.accept = "application/json";
  input.addEventListener("change", () => {
    const file = input.files && input.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try{
        applyImported(JSON.parse(String(reader.result || "")));
        render();
      }catch(e){
        alert("Import failed: " + (e && e.message ? e.message : "Invalid JSON"));
      }
    };
    reader.readAsText(file);
  });
  input.click();
}

/* =========================================================
   BOOT
   ========================================================= */

(function boot(){
  load();
  if (!state.warbandId && WARBANDS[0]) state.warbandId = WARBANDS[0].id;
  render();
})();
</script>
</body>
</html>
